<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üé• Professional Video Reaction Recorder</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body { 
      font-family: 'Arial', sans-serif; 
      text-align: center; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 10px;
      color: white;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 15px;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
    }
    
    h2 {
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    /* Video container - responsive */
    #videoContainer { 
      position: relative; 
      width: 100%;
      max-width: 95vw;
      max-height: 60vh;
      margin: 20px auto;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      border-radius: 15px;
      overflow: hidden;
      background: #000;
      touch-action: none;
    }
    
    #videoPlayer { 
      width: 100%; 
      height: 100%;
      display: block;
      background: #000;
      object-fit: contain;
      touch-action: none;
    }
    
    /* Camera overlay - improved for mobile */
    #reactionOverlay {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 150px;
      height: 150px;
      border: 3px solid #ff6b6b;
      border-radius: 50%;
      object-fit: cover;
      background: #000;
      z-index: 10;
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
      cursor: grab;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    
    #reactionOverlay:active {
      cursor: grabbing;
    }
    
    #reactionOverlay.resizing {
      border-color: #4CAF50;
      border-width: 4px;
    }

    /* File upload styling */
    .file-upload-container {
      margin: 20px 0;
      position: relative;
    }
    
    #uploadVideo {
      display: none;
    }
    
    .upload-label {
      display: inline-block;
      padding: 15px 30px;
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      color: white;
      border-radius: 50px;
      cursor: pointer;
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(238, 90, 36, 0.4);
    }
    
    .upload-label:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(238, 90, 36, 0.6);
    }

    /* Audio controls - responsive */
    .audio-controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 15px;
      border-radius: 25px;
      backdrop-filter: blur(5px);
      min-width: 200px;
    }
    
    .volume-control label {
      font-weight: bold;
      min-width: 70px;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    
    .volume-control input[type="range"] {
      flex: 1;
      height: 8px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      outline: none;
      appearance: none;
    }
    
    .volume-control input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      background: #ff6b6b;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Quality settings - mobile friendly */
    .quality-settings {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .quality-option {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 20px;
      backdrop-filter: blur(5px);
    }
    
    .quality-option select {
      background: transparent;
      color: white;
      border: none;
      font-size: clamp(0.9rem, 2vw, 1rem);
      cursor: pointer;
      padding: 5px;
    }
    
    .quality-option select option {
      background: #333;
      color: white;
    }

    /* Button styling - mobile optimized */
    .controls { 
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      transition: opacity 0.5s ease, transform 0.5s ease;
    }
    
    .controls.playing {
      opacity: 0;
      transform: translateY(-20px);
      pointer-events: none;
    }
    
    button {
      margin: 5px;
      padding: 12px 20px;
      border: none;
      border-radius: 25px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      cursor: pointer;
      font-size: clamp(0.8rem, 2vw, 1rem);
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      min-width: 120px;
      touch-action: manipulation;
    }
    
    button:hover:not(:disabled) { 
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
    }
    
    button:disabled { 
      background: #888;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      opacity: 0.6;
    }
    
    button.recording {
      background: linear-gradient(45deg, #ff4757, #ff3838);
      animation: pulse 1.5s ease-in-out infinite alternate;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4); }
      100% { box-shadow: 0 8px 30px rgba(255, 71, 87, 0.8); }
    }

    /* Status indicator */
    .status-indicator {
      margin: 15px 0;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      display: none;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    
    .status-indicator.show {
      display: block;
    }
    
    .status-indicator.recording {
      background: rgba(255, 71, 87, 0.2);
      border: 2px solid #ff4757;
    }
    
    .status-indicator.ready {
      background: rgba(46, 213, 115, 0.2);
      border: 2px solid #2ed573;
    }

    /* Preview container */
    #previewContainer { 
      margin-top: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
    }
    
    #previewVideo { 
      width: 100%;
      max-width: 600px;
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .hidden { display: none !important; }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      #reactionOverlay {
        width: 120px;
        height: 120px;
      }
      
      .volume-control {
        min-width: 180px;
        padding: 8px 12px;
      }
      
      button {
        min-width: 100px;
        padding: 10px 15px;
      }
    }
    
    @media (max-width: 480px) {
      #videoContainer {
        max-height: 50vh;
      }
      
      #reactionOverlay {
        width: 100px;
        height: 100px;
        left: 15px;
        top: 15px;
      }
      
      .volume-control {
        flex-direction: column;
        text-align: center;
        min-width: 150px;
      }
      
      .quality-settings {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üé• Professional Video Reaction Recorder</h2>

    <!-- Upload video -->
    <div class="file-upload-container">
      <input type="file" id="uploadVideo" accept="video/*" />
      <label for="uploadVideo" class="upload-label">üìπ Upload Video File</label>
    </div>

    <!-- Quality settings -->
    <div class="quality-settings">
      <div class="quality-option">
        <label>Quality: </label>
        <select id="videoQuality">
          <option value="1080p">1080p HD</option>
          <option value="720p" selected>720p (Recommended)</option>
          <option value="480p">480p</option>
        </select>
      </div>
      <div class="quality-option">
        <label>FPS: </label>
        <select id="frameRate">
          <option value="60">60 FPS</option>
          <option value="30" selected>30 FPS</option>
          <option value="24">24 FPS</option>
        </select>
      </div>
    </div>

    <!-- Audio controls -->
    <div class="audio-controls">
      <div class="volume-control">
        <label>Video Audio:</label>
        <input type="range" id="videoVolume" min="0" max="1" step="0.1" value="0.7">
        <span id="videoVolumeValue">70%</span>
      </div>
      <div class="volume-control">
        <label>Mic Audio:</label>
        <input type="range" id="cameraVolume" min="0" max="1" step="0.1" value="0.8">
        <span id="cameraVolumeValue">80%</span>
      </div>
    </div>

    <!-- Status indicator -->
    <div id="statusIndicator" class="status-indicator">
      <strong>Status:</strong> <span id="statusText">Ready to start</span>
    </div>

    <div id="videoContainer">
      <video id="videoPlayer" crossorigin="anonymous" playsinline></video>
      <video id="reactionOverlay" autoplay muted playsinline></video>
    </div>

    <div class="controls" id="mainControls">
      <button id="startCamera">üì∑ Enable Camera</button>
      <button id="switchCamera">üîÑ Switch Camera</button>
      <button id="pauseVideo" class="hidden">‚è∏Ô∏è Pause</button>
      <button id="startRecording">üî¥ Start Recording</button>
      <button id="stopRecording" disabled>‚èπÔ∏è Stop</button>
    </div>

    <div id="previewContainer" class="hidden">
      <h3>üé¨ Preview Recording</h3>
      <video id="previewVideo" controls playsinline></video>
      <div class="controls">
        <button id="downloadRecording">üíæ Download</button>
        <button id="discardRecording">üóëÔ∏è Try Again</button>
      </div>
    </div>
  </div>

  <script>
    // DOM elements
    const videoPlayer = document.getElementById("videoPlayer");
    const reactionOverlay = document.getElementById("reactionOverlay");
    const startCameraBtn = document.getElementById("startCamera");
    const switchCameraBtn = document.getElementById("switchCamera");
    const pauseVideoBtn = document.getElementById("pauseVideo");
    const startRecordingBtn = document.getElementById("startRecording");
    const stopRecordingBtn = document.getElementById("stopRecording");
    const previewContainer = document.getElementById("previewContainer");
    const previewVideo = document.getElementById("previewVideo");
    const downloadRecordingBtn = document.getElementById("downloadRecording");
    const discardRecordingBtn = document.getElementById("discardRecording");
    const statusIndicator = document.getElementById("statusIndicator");
    const statusText = document.getElementById("statusText");
    const videoVolumeSlider = document.getElementById("videoVolume");
    const cameraVolumeSlider = document.getElementById("cameraVolume");
    const videoVolumeValue = document.getElementById("videoVolumeValue");
    const cameraVolumeValue = document.getElementById("cameraVolumeValue");
    const videoQuality = document.getElementById("videoQuality");
    const frameRate = document.getElementById("frameRate");
    const mainControls = document.getElementById("mainControls");

    // Global variables
    let cameraStream = null;
    let currentFacing = "user";
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let canvas = null;
    let audioContext = null;
    let videoAudioGain = null;
    let cameraAudioGain = null;
    let mixedAudio = null;
    let isDragging = false;
    let isResizing = false;
    let startX = 0;
    let startY = 0;
    let initialDistance = 0;
    let initialSize = 150;

    // Update status function
    function updateStatus(message, type = 'ready') {
      statusText.textContent = message;
      statusIndicator.className = `status-indicator show ${type}`;
    }

    // Volume control handlers
    videoVolumeSlider.addEventListener('input', () => {
      const value = Math.round(videoVolumeSlider.value * 100);
      videoVolumeValue.textContent = `${value}%`;
      videoPlayer.volume = videoVolumeSlider.value;
      if (videoAudioGain) videoAudioGain.gain.value = videoVolumeSlider.value;
    });

    cameraVolumeSlider.addEventListener('input', () => {
      const value = Math.round(cameraVolumeSlider.value * 100);
      cameraVolumeValue.textContent = `${value}%`;
      if (cameraAudioGain) cameraAudioGain.gain.value = cameraVolumeSlider.value;
    });

    // File upload handler
    document.getElementById("uploadVideo").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file && file.type.startsWith("video/")) {
        updateStatus("Loading video...", "recording");
        
        const videoUrl = URL.createObjectURL(file);
        videoPlayer.src = videoUrl;
        videoPlayer.load();
        
        pauseVideoBtn.classList.remove("hidden");
        updateStatus("Video loaded! Enable camera to continue.", "ready");
      } else {
        alert("Please select a valid video file.");
      }
    });

    // Video loaded handler
    videoPlayer.addEventListener("loadedmetadata", () => {
      const quality = videoQuality.value;
      let width, height;
      
      const aspectRatio = videoPlayer.videoWidth / videoPlayer.videoHeight;
      
      switch(quality) {
        case '1080p':
          height = 1080;
          width = Math.round(height * aspectRatio);
          break;
        case '720p':
          height = 720;
          width = Math.round(height * aspectRatio);
          break;
        case '480p':
          height = 480;
          width = Math.round(height * aspectRatio);
          break;
        default:
          width = videoPlayer.videoWidth;
          height = videoPlayer.videoHeight;
      }
      
      canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      
      const container = document.getElementById('videoContainer');
      container.style.aspectRatio = `${aspectRatio}`;
      
      console.log(`Canvas: ${width}x${height}, Aspect: ${aspectRatio}`);
      updateStatus(`Video ready (${width}x${height})`, "ready");
    });

    // Camera functions
    async function startCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
      }
      
      updateStatus("Starting camera...", "recording");
      
      try {
        const constraints = {
          video: { 
            facingMode: currentFacing,
            width: { ideal: 1920, min: 640 },
            height: { ideal: 1080, min: 480 },
            frameRate: { ideal: 30 }
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: false,
            sampleRate: 48000
          }
        };
        
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        reactionOverlay.srcObject = cameraStream;
        
        startCameraBtn.textContent = "‚úÖ Camera Ready";
        startCameraBtn.disabled = true;
        updateStatus("Camera ready! You can now record.", "ready");
      } catch (err) {
        console.error("Camera error:", err);
        updateStatus("Camera access failed", "recording");
        alert("Please allow camera and microphone access to continue.");
      }
    }

    startCameraBtn.addEventListener("click", startCamera);

    // Switch camera
    switchCameraBtn.addEventListener("click", () => {
      currentFacing = currentFacing === "user" ? "environment" : "user";
      startCamera();
    });

    // Pause/play video
    function toggleVideoPlayback() {
      if (videoPlayer.paused) {
        videoPlayer.play();
        pauseVideoBtn.textContent = "‚è∏Ô∏è Pause";
      } else {
        videoPlayer.pause();
        pauseVideoBtn.textContent = "‚ñ∂Ô∏è Play";
      }
    }

    pauseVideoBtn.addEventListener("click", toggleVideoPlayback);

    // Auto-hide controls when playing
    videoPlayer.addEventListener("play", () => {
      mainControls.classList.add('playing');
    });

    videoPlayer.addEventListener("pause", () => {
      mainControls.classList.remove('playing');
    });

    // Touch and drag functionality for overlay
    function getTouchDistance(touch1, touch2) {
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function constrainPosition(element, container) {
      const containerRect = container.getBoundingClientRect();
      const elementRect = element.getBoundingClientRect();
      
      let left = element.offsetLeft;
      let top = element.offsetTop;
      
      left = Math.max(0, Math.min(left, containerRect.width - element.offsetWidth));
      top = Math.max(0, Math.min(top, containerRect.height - element.offsetHeight));
      
      element.style.left = left + "px";
      element.style.top = top + "px";
    }

    // Mouse events for overlay
    reactionOverlay.addEventListener("mousedown", (e) => {
      e.preventDefault();
      isDragging = true;
      startX = e.clientX - reactionOverlay.offsetLeft;
      startY = e.clientY - reactionOverlay.offsetTop;
      
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    });

    function handleMouseMove(e) {
      if (!isDragging || isResizing) return;
      
      const newLeft = e.clientX - startX;
      const newTop = e.clientY - startY;
      
      reactionOverlay.style.left = newLeft + "px";
      reactionOverlay.style.top = newTop + "px";
      
      constrainPosition(reactionOverlay, videoPlayer);
    }

    function handleMouseUp() {
      isDragging = false;
      isResizing = false;
      reactionOverlay.classList.remove('resizing');
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.removeEventListener("mousemove", handleMouseResize);
    }

    // Touch events for overlay - improved pinch support
    reactionOverlay.addEventListener("touchstart", (e) => {
      e.preventDefault();
      
      if (e.touches.length === 1) {
        // Single touch - drag
        isDragging = true;
        const touch = e.touches[0];
        startX = touch.clientX - reactionOverlay.offsetLeft;
        startY = touch.clientY - reactionOverlay.offsetTop;
      } else if (e.touches.length === 2) {
        // Two touches - resize
        isDragging = false;
        isResizing = true;
        reactionOverlay.classList.add('resizing');
        
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = getTouchDistance(touch1, touch2);
        initialSize = reactionOverlay.offsetWidth;
      }
    });

    reactionOverlay.addEventListener("touchmove", (e) => {
      e.preventDefault();
      
      if (isDragging && e.touches.length === 1) {
        // Drag
        const touch = e.touches[0];
        const newLeft = touch.clientX - startX;
        const newTop = touch.clientY - startY;
        
        reactionOverlay.style.left = newLeft + "px";
        reactionOverlay.style.top = newTop + "px";
        
        constrainPosition(reactionOverlay, videoPlayer);
        
      } else if (isResizing && e.touches.length === 2) {
        // Pinch to resize
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = getTouchDistance(touch1, touch2);
        const scale = currentDistance / initialDistance;
        
        let newSize = Math.max(80, Math.min(300, initialSize * scale));
        
        // Check container bounds
        const containerRect = videoPlayer.getBoundingClientRect();
        const maxWidth = containerRect.width - reactionOverlay.offsetLeft;
        const maxHeight = containerRect.height - reactionOverlay.offsetTop;
        newSize = Math.min(newSize, Math.min(maxWidth, maxHeight));
        
        reactionOverlay.style.width = newSize + "px";
        reactionOverlay.style.height = newSize + "px";
      }
    });

    reactionOverlay.addEventListener("touchend", (e) => {
      e.preventDefault();
      isDragging = false;
      isResizing = false;
      reactionOverlay.classList.remove('resizing');
    });

    // Recording functions
    function resetRecordingUI() {
      startRecordingBtn.textContent = "üî¥ Start Recording";
      startRecordingBtn.classList.remove("recording");
      startRecordingBtn.disabled = false;
      stopRecordingBtn.disabled = true;
    }

    async function startRecording() {
      console.log("Starting recording...");
      
      // Validation
      if (!cameraStream) {
        alert("Please enable camera first");
        updateStatus("Camera required", "recording");
        return;
      }
      
      if (!videoPlayer.src) {
        alert("Please upload a video first");
        updateStatus("Video required", "recording");
        return;
      }
      
      if (!canvas) {
        alert("Please wait for video to load");
        updateStatus("Loading video...", "recording");
        return;
      }

      // Reset previous recording
      recordedChunks = [];
      
      // UI updates
      startRecordingBtn.textContent = "üî¥ Recording...";
      startRecordingBtn.classList.add("recording");
      startRecordingBtn.disabled = true;
      stopRecordingBtn.disabled = false;
      updateStatus("Recording started! Click Stop when done.", "recording");

      const ctx = canvas.getContext("2d");
      const fps = parseInt(frameRate.value);
      
      function drawFrame() {
        if (!isRecording) return;
        
        try {
          // Clear canvas
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw main video
          if (videoPlayer.readyState >= 2) {
            ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
          }
          
          // Draw reaction overlay
          if (reactionOverlay.readyState >= 2) {
            const containerRect = videoPlayer.getBoundingClientRect();
            const overlayRect = reactionOverlay.getBoundingClientRect();
            
            const scaleX = canvas.width / containerRect.width;
            const scaleY = canvas.height / containerRect.height;
            
            const x = (overlayRect.left - containerRect.left) * scaleX;
            const y = (overlayRect.top - containerRect.top) * scaleY;
            const size = overlayRect.width * Math.min(scaleX, scaleY);
            
            if (size > 0 && x >= 0 && y >= 0) {
              // Save context
              ctx.save();
              
              // Create circular clip
              const centerX = x + size/2;
              const centerY = y + size/2;
              const radius = size/2;
              
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
              ctx.clip();
              
              // Draw camera feed
              ctx.drawImage(reactionOverlay, x, y, size, size);
              
              // Restore context
              ctx.restore();
              
              // Draw border
              ctx.strokeStyle = '#ff6b6b';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
              ctx.stroke();
            }
          }
        } catch (error) {
          console.error("Drawing error:", error);
        }
        
        if (isRecording) {
          setTimeout(() => requestAnimationFrame(drawFrame), 1000 / fps);
        }
      }

      try {
        // Audio setup
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const videoSource = audioContext.createMediaElementSource(videoPlayer);
        const cameraSource = audioContext.createMediaStreamSource(cameraStream);
        
        videoAudioGain = audioContext.createGain();
        cameraAudioGain = audioContext.createGain();
        
        videoAudioGain.gain.value = parseFloat(videoVolumeSlider.value);
        cameraAudioGain.gain.value = parseFloat(cameraVolumeSlider.value);
        
        const compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressor.knee.setValueAtTime(30, audioContext.currentTime);
        compressor.ratio.setValueAtTime(12, audioContext.currentTime);
        compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
        compressor.release.setValueAtTime(0.25, audioContext.currentTime);
        
        mixedAudio = audioContext.createMediaStreamDestination();
        
        videoSource.connect(videoAudioGain);
        cameraSource.connect(cameraAudioGain);
        videoAudioGain.connect(compressor);
        cameraAudioGain.connect(compressor);
        compressor.connect(mixedAudio);
        
        // Create final stream
        const canvasStream = canvas.captureStream(fps);
        const audioTracks = mixedAudio.stream.getAudioTracks();
        
        const finalStream = new MediaStream([canvasStream.getVideoTracks()[0]]);
        if (audioTracks.length > 0) {
          finalStream.addTrack(audioTracks[0]);
        }

        // MediaRecorder setup with fallbacks
        let options;
        if (MediaRecorder.isTypeSupported('video/webm; codecs=vp9,opus')) {
          options = {
            mimeType: 'video/webm; codecs=vp9,opus',
            videoBitsPerSecond: 8000000,
            audioBitsPerSecond: 128000
          };
        } else if (MediaRecorder.isTypeSupported('video/webm; codecs=vp8,opus')) {
          options = {
            mimeType: 'video/webm; codecs=vp8,opus',
            videoBitsPerSecond: 5000000,
            audioBitsPerSecond: 128000
          };
        } else {
          options = {
            mimeType: 'video/webm',
            videoBitsPerSecond: 3000000,
            audioBitsPerSecond: 128000
          };
        }

        console.log("Using recording options:", options);
        
        mediaRecorder = new MediaRecorder(finalStream, options);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) {
            recordedChunks.push(event.data);
            console.log("Chunk recorded:", event.data.size, "bytes");
          }
        };

        mediaRecorder.onstop = () => {
          console.log("Recording stopped. Chunks:", recordedChunks.length);
          
          if (recordedChunks.length > 0) {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            console.log("Final recording size:", blob.size, "bytes");
            
            const url = URL.createObjectURL(blob);
            previewVideo.src = url;
            previewContainer.classList.remove("hidden");
            updateStatus("Recording completed! Preview and download below.", "ready");
          } else {
            updateStatus("Recording failed - no data captured", "recording");
            alert("Recording failed. Please try again.");
          }
          
          resetRecordingUI();
          if (audioContext) audioContext.close();
        };

        mediaRecorder.onerror = (event) => {
          console.error("Recording error:", event.error);
          updateStatus("Recording error occurred", "recording");
          alert("Recording error: " + event.error.message);
          resetRecordingUI();
          if (audioContext) audioContext.close();
        };

        // Start recording
        isRecording = true;
        videoPlayer.play();
        mediaRecorder.start(100);
        drawFrame();
        
        console.log("Recording started successfully");

      } catch (error) {
        console.error("Recording setup failed:", error);
        updateStatus("Recording setup failed", "recording");
        alert("Failed to start recording: " + error.message);
        resetRecordingUI();
        if (audioContext) audioContext.close();
      }
    }

    function stopRecording() {
      console.log("Stopping recording...");
      
      if (mediaRecorder && isRecording) {
        isRecording = false;
        updateStatus("Finalizing recording...", "recording");
        
        try {
          mediaRecorder.stop();
        } catch (error) {
          console.error("Error stopping recording:", error);
          resetRecordingUI();
        }
      } else {
        console.log("No active recording to stop");
      }
    }

    // Event listeners
    startRecordingBtn.addEventListener("click", startRecording);
    stopRecordingBtn.addEventListener("click", stopRecording);

    // Download recording
    downloadRecordingBtn.addEventListener("click", () => {
      const url = previewVideo.src;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `reaction-video-${timestamp}.webm`;
      
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      updateStatus("Recording downloaded successfully!", "ready");
    });

    // Discard recording
    discardRecordingBtn.addEventListener("click", () => {
      previewContainer.classList.add("hidden");
      previewVideo.src = "";
      recordedChunks = [];
      updateStatus("Recording discarded. Ready for new recording.", "ready");
    });

    // Window resize handler
    window.addEventListener('resize', () => {
      constrainPosition(reactionOverlay, videoPlayer);
    });

    // Initialize
    updateStatus("Upload a video and enable camera to begin recording", "ready");

    // Prevent context menu on long press
    document.addEventListener('contextmenu', (e) => {
      if (e.target === reactionOverlay) {
        e.preventDefault();
      }
    });

    // Handle orientation change on mobile
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        constrainPosition(reactionOverlay, videoPlayer);
      }, 500);
    });

    console.log("Professional Video Recorder initialized successfully!");
  </script>
</body>
</html>