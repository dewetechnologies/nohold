<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>🎥 Professional Video Reaction Recorder</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body { 
      font-family: 'Arial', sans-serif; 
      text-align: center; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 10px;
      color: white;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 15px;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
    }
    
    h2 {
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    /* Video Source Selection */
    .video-source-section {
      margin: 20px 0;
      padding: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(5px);
    }
    
    .source-selector {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    
    .source-option {
      flex: 1;
      min-width: 200px;
      max-width: 250px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid transparent;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
    }
    
    .source-option:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 255, 255, 0.2);
    }
    
    .source-option.active {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.2);
    }
    
    .source-option h4 {
      margin: 0 0 10px 0;
      font-size: 1.2rem;
    }
    
    .source-option p {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    /* Camera/Video Source Selection */
    .camera-selector {
      margin: 20px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 15px;
      backdrop-filter: blur(5px);
    }
    
    .camera-selector select {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 10px 15px;
      font-size: 1rem;
      cursor: pointer;
      width: 100%;
      max-width: 300px;
      margin: 10px 0;
    }
    
    .camera-selector select option {
      background: #333;
      color: white;
    }
    
    /* Video container - portrait mode */
    #videoContainer { 
      position: relative; 
      width: 100%;
      max-width: 95vw;
      height: 70vh;
      margin: 20px auto;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      border-radius: 15px;
      overflow: hidden;
      background: #000;
      touch-action: none;
    }
    
    #videoPlayer { 
      width: 100%; 
      height: 100%;
      display: block;
      background: #000;
      object-fit: contain;
      touch-action: none;
      z-index: 1;
    }
    
    /* Camera bar at the top with adjustable yellow line */
    #cameraBar {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 120px; /* Default height */
      background: #000;
      z-index: 20;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      border-bottom: 4px solid #ffcc00;
    }
    
    #cameraBar video {
      height: 100%;
      width: 100%;
      object-fit: cover;
    }
    
    /* Yellow line handle for adjusting height */
    #lineHandle {
      position: absolute;
      bottom: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      background: #ffcc00;
      border-radius: 10px;
      cursor: ns-resize;
      z-index: 30;
      touch-action: none;
    }
    
    /* Position controls */
    .position-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
      flex-wrap: wrap;
    }
    
    .position-btn {
      padding: 10px 15px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .position-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    /* File upload styling */
    .file-upload-container {
      margin: 20px 0;
      position: relative;
    }
    
    #uploadVideo {
      display: none;
    }
    
    .upload-label {
      display: inline-block;
      padding: 15px 30px;
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      color: white;
      border-radius: 50px;
      cursor: pointer;
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(238, 90, 36, 0.4);
    }
    
    .upload-label:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(238, 90, 36, 0.6);
    }
    
    .upload-label.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Audio controls - responsive */
    .audio-controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 15px;
      border-radius: 25px;
      backdrop-filter: blur(5px);
      min-width: 200px;
    }
    
    .volume-control label {
      font-weight: bold;
      min-width: 70px;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    
    .volume-control input[type="range"] {
      flex: 1;
      height: 8px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      outline: none;
      appearance: none;
    }
    
    .volume-control input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      background: #ff6b6b;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Quality settings - mobile friendly */
    .quality-settings {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .quality-option {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 20px;
      backdrop-filter: blur(5px);
    }
    
    .quality-option select {
      background: transparent;
      color: white;
      border: none;
      font-size: clamp(0.9rem, 2vw, 1rem);
      cursor: pointer;
      padding: 5px;
    }
    
    .quality-option select option {
      background: #333;
      color: white;
    }

    /* Button styling - mobile optimized */
    .controls { 
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    button {
      margin: 5px;
      padding: 12px 20px;
      border: none;
      border-radius: 25px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      cursor: pointer;
      font-size: clamp(0.8rem, 2vw, 1rem);
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      min-width: 120px;
      touch-action: manipulation;
    }
    
    button:hover:not(:disabled) { 
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
    }
    
    button:disabled { 
      background: #888;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      opacity: 0.6;
    }
    
    button.recording {
      background: linear-gradient(45deg, #ff4757, #ff3838);
      animation: pulse 1.5s ease-in-out infinite alternate;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4); }
      100% { box-shadow: 0 8px 30px rgba(255, 71, 87, 0.8); }
    }

    /* Status indicator */
    .status-indicator {
      margin: 15px 0;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      display: none;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    
    .status-indicator.show {
      display: block;
    }
    
    .status-indicator.recording {
      background: rgba(255, 71, 87, 0.2);
      border: 2px solid #ff4757;
    }
    
    .status-indicator.ready {
      background: rgba(46, 213, 115, 0.2);
      border: 2px solid #2ed573;
    }

    /* Preview container */
    #previewContainer { 
      margin-top: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
    }
    
    #previewVideo { 
      width: 100%;
      max-width: 600px;
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .hidden { display: none !important; }
    
    /* Recording timer */
    .recording-timer {
      font-size: 1.2rem;
      font-weight: bold;
      margin: 10px 0;
      display: none;
    }
    
    .recording-timer.show {
      display: block;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .source-selector {
        flex-direction: column;
        align-items: center;
      }
      
      .source-option {
        min-width: 90%;
      }
      
      #videoContainer {
        height: 60vh;
      }
      
      #cameraBar {
        height: 100px;
      }
      
      .volume-control {
        min-width: 180px;
        padding: 8px 12px;
      }
      
      button {
        min-width: 100px;
        padding: 10px 15px;
      }
    }
    
    @media (max-width: 480px) {
      #videoContainer {
        height: 50vh;
      }
      
      #cameraBar {
        height: 80px;
      }
      
      .volume-control {
        flex-direction: column;
        text-align: center;
        min-width: 150px;
      }
      
      .quality-settings {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>🎥 Professional Video Reaction Recorder</h2>

    <!-- Video Source Selection -->
    <div class="video-source-section">
      <h3>📹 Select Video Source</h3>
      <div class="source-selector">
        <div class="source-option" id="fileSourceOption">
          <h4>📁 Upload File</h4>
          <p>Upload a video file from your device</p>
        </div>
        <div class="source-option" id="cameraSourceOption">
          <h4>📹 Camera/Phone</h4>
          <p>Use camera or phone via Iriun Webcam</p>
        </div>
      </div>

      <!-- File Upload (shown when file source is selected) -->
      <div class="file-upload-container" id="fileUploadSection" style="display: none;">
        <input type="file" id="uploadVideo" accept="video/*" />
        <label for="uploadVideo" class="upload-label">📹 Choose Video File</label>
      </div>

      <!-- Camera/Video Input Selector -->
      <div class="camera-selector" id="videoInputSection" style="display: none;">
        <h4>📹 Select Video Input</h4>
        <select id="videoInputSelect">
          <option value="">Choose video input...</option>
        </select>
        <button id="refreshInputs">🔄 Refresh Inputs</button>
      </div>
    </div>

    <!-- Video position controls -->
    <div class="position-controls">
      <div class="position-btn" id="moveUp">Move Up</div>
      <div class="position-btn" id="moveDown">Move Down</div>
      <div class="position-btn" id="moveLeft">Move Left</div>
      <div class="position-btn" id="moveRight">Move Right</div>
      <div class="position-btn" id="resetPosition">Reset Position</div>
    </div>

    <!-- Quality settings -->
    <div class="quality-settings">
      <div class="quality-option">
        <label>Quality: </label>
        <select id="videoQuality">
          <option value="1080p">1080p HD</option>
          <option value="720p" selected>720p (Recommended)</option>
          <option value="480p">480p</option>
        </select>
      </div>
      <div class="quality-option">
        <label>FPS: </label>
        <select id="frameRate">
          <option value="60">60 FPS</option>
          <option value="30" selected>30 FPS</option>
          <option value="24">24 FPS</option>
        </select>
      </div>
    </div>

    <!-- Audio controls -->
    <div class="audio-controls">
      <div class="volume-control">
        <label>Video Audio:</label>
        <input type="range" id="videoVolume" min="0" max="1" step="0.1" value="0.7">
        <span id="videoVolumeValue">70%</span>
      </div>
      <div class="volume-control">
        <label>Mic Audio:</label>
        <input type="range" id="cameraVolume" min="0" max="1" step="0.1" value="0.8">
        <span id="cameraVolumeValue">80%</span>
      </div>
    </div>

    <!-- Status indicator -->
    <div id="statusIndicator" class="status-indicator">
      <strong>Status:</strong> <span id="statusText">Select a video source to begin</span>
    </div>

    <!-- Recording timer -->
    <div id="recordingTimer" class="recording-timer">
      ⏱️ Recording: <span id="timerDisplay">00:00</span>
    </div>

    <div id="videoContainer">
      <video id="videoPlayer" crossorigin="anonymous" playsinline></video>
      <div id="cameraBar">
        <video id="cameraFeed" autoplay muted playsinline></video>
        <div id="lineHandle"></div>
      </div>
    </div>

    <div class="controls" id="mainControls">
      <button id="startCamera">📷 Enable Camera</button>
      <button id="switchCamera">🔄 Switch Camera</button>
      <button id="pauseVideo" class="hidden">⏸️ Pause</button>
      <button id="startRecording">🔴 Start Recording</button>
      <button id="stopRecording" disabled>⏹️ Stop</button>
    </div>

    <div id="previewContainer" class="hidden">
      <h3>🎬 Preview Recording</h3>
      <video id="previewVideo" controls playsinline></video>
      <div class="controls">
        <button id="downloadRecording">💾 Download</button>
        <button id="discardRecording">🗑️ Try Again</button>
      </div>
    </div>
  </div>

  <script>
    // DOM elements
    const videoPlayer = document.getElementById("videoPlayer");
    const cameraFeed = document.getElementById("cameraFeed");
    const startCameraBtn = document.getElementById("startCamera");
    const switchCameraBtn = document.getElementById("switchCamera");
    const pauseVideoBtn = document.getElementById("pauseVideo");
    const startRecordingBtn = document.getElementById("startRecording");
    const stopRecordingBtn = document.getElementById("stopRecording");
    const previewContainer = document.getElementById("previewContainer");
    const previewVideo = document.getElementById("previewVideo");
    const downloadRecordingBtn = document.getElementById("downloadRecording");
    const discardRecordingBtn = document.getElementById("discardRecording");
    const statusIndicator = document.getElementById("statusIndicator");
    const statusText = document.getElementById("statusText");
    const videoVolumeSlider = document.getElementById("videoVolume");
    const cameraVolumeSlider = document.getElementById("cameraVolume");
    const videoVolumeValue = document.getElementById("videoVolumeValue");
    const cameraVolumeValue = document.getElementById("cameraVolumeValue");
    const videoQuality = document.getElementById("videoQuality");
    const frameRate = document.getElementById("frameRate");
    const mainControls = document.getElementById("mainControls");
    const recordingTimer = document.getElementById("recordingTimer");
    const timerDisplay = document.getElementById("timerDisplay");
    const cameraBar = document.getElementById("cameraBar");
    const lineHandle = document.getElementById("lineHandle");

    // Video source elements
    const fileSourceOption = document.getElementById("fileSourceOption");
    const cameraSourceOption = document.getElementById("cameraSourceOption");
    const fileUploadSection = document.getElementById("fileUploadSection");
    const videoInputSection = document.getElementById("videoInputSection");
    const videoInputSelect = document.getElementById("videoInputSelect");
    const refreshInputsBtn = document.getElementById("refreshInputs");

    // Position control elements
    const moveUpBtn = document.getElementById("moveUp");
    const moveDownBtn = document.getElementById("moveDown");
    const moveLeftBtn = document.getElementById("moveLeft");
    const moveRightBtn = document.getElementById("moveRight");
    const resetPositionBtn = document.getElementById("resetPosition");

    // Global variables
    let cameraStream = null;
    let currentFacing = "user";
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let canvas = null;
    let audioContext = null;
    let videoAudioGain = null;
    let cameraAudioGain = null;
    let mixedAudio = null;
    let selectedVideoSource = null; // 'file' or 'camera'
    let availableVideoInputs = [];
    let recordingStartTime = 0;
    let timerInterval = null;
    let isVideoPaused = false;
    let videoPosition = { x: 0, y: 0 };
    let isResizingCameraBar = false;

    // Update status function
    function updateStatus(message, type = 'ready') {
      statusText.textContent = message;
      statusIndicator.className = `status-indicator show ${type}`;
    }

    // Update timer function
    function updateTimer() {
      if (!isRecording) return;
      
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // Video source selection handlers
    fileSourceOption.addEventListener('click', () => {
      selectVideoSource('file');
    });

    cameraSourceOption.addEventListener('click', () => {
      selectVideoSource('camera');
    });

    function selectVideoSource(source) {
      selectedVideoSource = source;
      
      // Update UI
      document.querySelectorAll('.source-option').forEach(el => el.classList.remove('active'));
      
      if (source === 'file') {
        fileSourceOption.classList.add('active');
        fileUploadSection.style.display = 'block';
        videoInputSection.style.display = 'none';
        updateStatus('Upload a video file to continue', 'ready');
        
        // Stop any existing camera stream
        if (cameraStream) {
          cameraStream.getTracks().forEach(t => t.stop());
          cameraStream = null;
        }
        videoPlayer.srcObject = null;
        
      } else if (source === 'camera') {
        cameraSourceOption.classList.add('active');
        fileUploadSection.style.display = 'none';
        videoInputSection.style.display = 'block';
        updateStatus('Select a video input source', 'ready');
        
        // Clear file source
        videoPlayer.src = '';
        document.getElementById('uploadVideo').value = '';
        
        // Load available video inputs
        loadVideoInputs();
      }
    }

    // Load available video inputs
    async function loadVideoInputs() {
      try {
        // Request permission first
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        stream.getTracks().forEach(track => track.stop());
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoInputs = devices.filter(device => device.kind === 'videoinput');
        
        availableVideoInputs = videoInputs;
        
        videoInputSelect.innerHTML = '<option value="">Choose video input...</option>';
        
        videoInputs.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `Camera ${index + 1}`;
          videoInputSelect.appendChild(option);
        });
        
        updateStatus(`Found ${videoInputs.length} video input(s)`, 'ready');
        
      } catch (error) {
        console.error('Error loading video inputs:', error);
        updateStatus('Unable to access video devices', 'recording');
      }
    }

    // Refresh video inputs
    refreshInputsBtn.addEventListener('click', loadVideoInputs);

    // Video input selection handler
    videoInputSelect.addEventListener('change', async (e) => {
      const deviceId = e.target.value;
      if (!deviceId) return;
      
      updateStatus('Starting video input...', 'recording');
      
      try {
        // Stop existing stream
        if (cameraStream) {
          cameraStream.getTracks().forEach(t => t.stop());
        }
        
        // Start new stream with selected device
        const constraints = {
          video: {
            deviceId: { exact: deviceId },
            width: { ideal: 1920, min: 640 },
            height: { ideal: 1080, min: 480 },
            frameRate: { ideal: 30 }
          }
        };
        
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoPlayer.srcObject = stream;
        cameraStream = stream;
        
        // Setup canvas for recording
        videoPlayer.addEventListener('loadedmetadata', setupCanvasForCamera, { once: true });
        
        pauseVideoBtn.classList.remove("hidden");
        updateStatus('Video input ready! Enable camera for overlay.', 'ready');
        
      } catch (error) {
        console.error('Error starting video input:', error);
        updateStatus('Failed to start video input', 'recording');
        alert('Failed to start video input. Please check your camera connection.');
      }
    });

    // Setup canvas for camera input
    function setupCanvasForCamera() {
      const quality = videoQuality.value;
      let width, height;
      
      const aspectRatio = videoPlayer.videoWidth / videoPlayer.videoHeight;
      
      switch(quality) {
        case '1080p':
          height = 1080;
          width = Math.round(height * aspectRatio);
          break;
        case '720p':
          height = 720;
          width = Math.round(height * aspectRatio);
          break;
        case '480p':
          height = 480;
          width = Math.round(height * aspectRatio);
          break;
        default:
          width = videoPlayer.videoWidth;
          height = videoPlayer.videoHeight;
      }
      
      canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      
      const container = document.getElementById('videoContainer');
      container.style.aspectRatio = `${aspectRatio}`;
      
      console.log(`Canvas: ${width}x${height}, Aspect: ${aspectRatio}`);
      updateStatus(`Video input ready (${width}x${height})`, "ready");
    }

    // Volume control handlers
    videoVolumeSlider.addEventListener('input', () => {
      const value = Math.round(videoVolumeSlider.value * 100);
      videoVolumeValue.textContent = `${value}%`;
      videoPlayer.volume = videoVolumeSlider.value;
      if (videoAudioGain) videoAudioGain.gain.value = videoVolumeSlider.value;
    });

    cameraVolumeSlider.addEventListener('input', () => {
      const value = Math.round(cameraVolumeSlider.value * 100);
      cameraVolumeValue.textContent = `${value}%`;
      if (cameraAudioGain) cameraAudioGain.gain.value = cameraVolumeSlider.value;
    });

    // File upload handler (only works when file source is selected)
    document.getElementById("uploadVideo").addEventListener("change", (e) => {
      if (selectedVideoSource !== 'file') return;
      
      const file = e.target.files[0];
      if (file && file.type.startsWith("video/")) {
        updateStatus("Loading video...", "recording");
        
        const videoUrl = URL.createObjectURL(file);
        videoPlayer.src = videoUrl;
        videoPlayer.srcObject = null; // Clear any camera stream
        videoPlayer.load();
        
        pauseVideoBtn.classList.remove("hidden");
        updateStatus("Video loaded! Enable camera to continue.", "ready");
      } else {
        alert("Please select a valid video file.");
      }
    });

     // Video loaded handler
    videoPlayer.addEventListener("loadedmetadata", () => {
      if (selectedVideoSource === 'file') {
        // Set the video volume to the slider value
        videoPlayer.volume = videoVolumeSlider.value;
        
        const quality = videoQuality.value;
        let width, height;
        
        const aspectRatio = videoPlayer.videoWidth / videoPlayer.videoHeight;
        
        switch(quality) {
          case '1080p':
            height = 1080;
            width = Math.round(height * aspectRatio);
            break;
          case '720p':
            height = 720;
            width = Math.round(height * aspectRatio);
            break;
          case '480p':
            height = 480;
            width = Math.round(height * aspectRatio);
            break;
          default:
            width = videoPlayer.videoWidth;
            height = videoPlayer.videoHeight;
        }
        
        canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        
        const container = document.getElementById('videoContainer');
        container.style.aspectRatio = `${aspectRatio}`;
        
        console.log(`Canvas: ${width}x${height}, Aspect: ${aspectRatio}`);
        updateStatus(`Video ready (${width}x${height})`, "ready");
      }
    });

    // Camera functions (for camera bar)
    async function startCamera() {
      if (cameraFeed.srcObject) {
        const stream = cameraFeed.srcObject;
        stream.getTracks().forEach(t => t.stop());
      }
      
      updateStatus("Starting camera...", "recording");
      
      try {
        const constraints = {
          video: { 
            facingMode: currentFacing,
            width: { ideal: 1920, min: 640 },
            height: { ideal: 1080, min: 480 },
            frameRate: { ideal: 30 }
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: false,
            sampleRate: 48000
          }
        };
        
        const reactionStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraFeed.srcObject = reactionStream;
        
        startCameraBtn.textContent = "✅ Camera Ready";
        startCameraBtn.disabled = true;
        updateStatus("Camera ready! You can now record.", "ready");
      } catch (err) {
        console.error("Camera error:", err);
        updateStatus("Camera access failed", "recording");
        alert("Please allow camera and microphone access for camera bar.");
      }
    }

    startCameraBtn.addEventListener("click", startCamera);

    // Switch camera
    switchCameraBtn.addEventListener("click", () => {
      currentFacing = currentFacing === "user" ? "environment" : "user";
      startCamera();
    });

    // Pause/play video
    function toggleVideoPlayback() {
      if (videoPlayer.paused) {
        videoPlayer.play();
        pauseVideoBtn.textContent = "⏸️ Pause";
        isVideoPaused = false;
      } else {
        videoPlayer.pause();
        pauseVideoBtn.textContent = "▶️ Play";
        isVideoPaused = true;
      }
    }

    pauseVideoBtn.addEventListener("click", toggleVideoPlayback);

    // Video position controls
    moveUpBtn.addEventListener("click", () => {
      videoPosition.y = Math.max(videoPosition.y - 10, -100);
      updateVideoPosition();
    });

    moveDownBtn.addEventListener("click", () => {
      videoPosition.y = Math.min(videoPosition.y + 10, 100);
      updateVideoPosition();
    });

    moveLeftBtn.addEventListener("click", () => {
      videoPosition.x = Math.max(videoPosition.x - 10, -100);
      updateVideoPosition();
    });

    moveRightBtn.addEventListener("click", () => {
      videoPosition.x = Math.min(videoPosition.x + 10, 100);
      updateVideoPosition();
    });

    resetPositionBtn.addEventListener("click", () => {
      videoPosition = { x: 0, y: 0 };
      updateVideoPosition();
    });

    function updateVideoPosition() {
      videoPlayer.style.transform = `translate(${videoPosition.x}px, ${videoPosition.y}px)`;
    }

    // Camera bar height adjustment
    lineHandle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isResizingCameraBar = true;
      document.addEventListener('mousemove', handleCameraBarResize);
      document.addEventListener('mouseup', stopCameraBarResize);
    });

    lineHandle.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isResizingCameraBar = true;
      document.addEventListener('touchmove', handleCameraBarResizeTouch, { passive: false });
      document.addEventListener('touchend', stopCameraBarResize);
    });

    function handleCameraBarResize(e) {
      if (!isResizingCameraBar) return;
      
      const containerRect = videoContainer.getBoundingClientRect();
      const newHeight = Math.max(60, Math.min(containerRect.height - 100, e.clientY - containerRect.top));
      
      cameraBar.style.height = `${newHeight}px`;
    }

    function handleCameraBarResizeTouch(e) {
      if (!isResizingCameraBar) return;
      e.preventDefault();
      
      const containerRect = videoContainer.getBoundingClientRect();
      const newHeight = Math.max(60, Math.min(containerRect.height - 100, e.touches[0].clientY - containerRect.top));
      
      cameraBar.style.height = `${newHeight}px`;
    }

    function stopCameraBarResize() {
      isResizingCameraBar = false;
      document.removeEventListener('mousemove', handleCameraBarResize);
      document.removeEventListener('touchmove', handleCameraBarResizeTouch);
    }

    // Touch events for video positioning
    const videoContainer = document.getElementById('videoContainer');
    let touchStartX = 0;
    let touchStartY = 0;
    let initialVideoPosition = { x: 0, y: 0 };

    videoContainer.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1 && e.target.id !== 'lineHandle') {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        initialVideoPosition = { ...videoPosition };
      }
    });

    videoContainer.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1 && e.target.id !== 'lineHandle') {
        e.preventDefault();
        
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        
        const deltaX = touchX - touchStartX;
        const deltaY = touchY - touchStartY;
        
        // Calculate new position with boundaries
        const containerRect = videoContainer.getBoundingClientRect();
        const maxX = containerRect.width * 0.3;
        const maxY = containerRect.height * 0.3;
        
        videoPosition.x = Math.max(-maxX, Math.min(maxX, initialVideoPosition.x + deltaX));
        videoPosition.y = Math.max(-maxY, Math.min(maxY, initialVideoPosition.y + deltaY));
        
        updateVideoPosition();
      }
    });

    // Recording functions
    function resetRecordingUI() {
      startRecordingBtn.textContent = "🔴 Start Recording";
      startRecordingBtn.classList.remove("recording");
      startRecordingBtn.disabled = false;
      stopRecordingBtn.disabled = true;
      recordingTimer.classList.remove("show");
      
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    async function startRecording() {
      console.log("Starting recording...");
      
      // Validation
      if (!cameraFeed.srcObject) {
        alert("Please enable camera first");
        updateStatus("Camera required", "recording");
        return;
      }
      
      if (selectedVideoSource === 'file' && !videoPlayer.src) {
        alert("Please upload a video first");
        updateStatus("Video required", "recording");
        return;
      }
      
      if (selectedVideoSource === 'camera' && !videoPlayer.srcObject) {
        alert("Please select a video input source first");
        updateStatus("Video input required", "recording");
        return;
      }
      
      if (!canvas) {
        alert("Please wait for video to load");
        updateStatus("Loading video...", "recording");
        return;
      }

      // Reset previous recording
      recordedChunks = [];
      
      // UI updates
      startRecordingBtn.textContent = "🔴 Recording...";
      startRecordingBtn.classList.add("recording");
      startRecordingBtn.disabled = true;
      stopRecordingBtn.disabled = false;
      recordingTimer.classList.add("show");
      recordingStartTime = Date.now();
      
      // Start timer
      timerInterval = setInterval(updateTimer, 1000);
      updateTimer();
      
      updateStatus("Recording started! Click Stop when done.", "recording");

      const ctx = canvas.getContext("2d");
      const fps = parseInt(frameRate.value);
      
    function drawFrame() {
        if (!isRecording) return;
        
        try {
          // Clear canvas
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw main video (only if not paused)
          if (!isVideoPaused && videoPlayer.readyState >= 2) {
            ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
          } else if (isVideoPaused && videoPlayer.readyState >= 2) {
            // Draw the current frame even when paused
            ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
          }
          
          // Draw camera bar at the top
          if (cameraFeed.readyState >= 2) {
            const barHeight = Math.min(canvas.height * (parseInt(cameraBar.style.height) / videoContainer.offsetHeight), canvas.height * 0.5);
            const barWidth = canvas.width;
            
            // Draw camera feed
            ctx.drawImage(cameraFeed, 0, 0, barWidth, barHeight);
            
            // Draw yellow bottom border
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, barHeight);
            ctx.lineTo(barWidth, barHeight);
            ctx.stroke();
          }
        } catch (error) {
          console.error("Drawing error:", error);
        }
        
        if (isRecording) {
          setTimeout(() => requestAnimationFrame(drawFrame), 1000 / fps);
        }
      }

      try {
        // Audio setup
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        let videoSource, cameraSource;
        
        // Handle different video sources
        if (selectedVideoSource === 'file' && videoPlayer.src) {
          // For file source, we need to handle audio differently to hear it during playback
          videoSource = audioContext.createMediaElementSource(videoPlayer);
          
          // Create a separate audio element for playback
          const playbackAudio = document.createElement('audio');
          playbackAudio.src = videoPlayer.src;
          playbackAudio.volume = videoPlayer.volume;
          playbackAudio.currentTime = videoPlayer.currentTime;
          if (!isVideoPaused) {
            playbackAudio.play().catch(e => console.log("Audio play failed:", e));
          }
        } else if (selectedVideoSource === 'camera' && videoPlayer.srcObject) {
          videoSource = audioContext.createMediaStreamSource(videoPlayer.srcObject);
        }
        
        // Camera audio
        cameraSource = audioContext.createMediaStreamSource(cameraFeed.srcObject);
        
        videoAudioGain = audioContext.createGain();
        cameraAudioGain = audioContext.createGain();
        
        videoAudioGain.gain.value = parseFloat(videoVolumeSlider.value);
        cameraAudioGain.gain.value = parseFloat(cameraVolumeSlider.value);
        
        const compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressor.knee.setValueAtTime(30, audioContext.currentTime);
        compressor.ratio.setValueAtTime(12, audioContext.currentTime);
        compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
        compressor.release.setValueAtTime(0.25, audioContext.currentTime);
        
        mixedAudio = audioContext.createMediaStreamDestination();
        
        if (videoSource) {
          videoSource.connect(videoAudioGain);
          videoAudioGain.connect(compressor);
        }
        cameraSource.connect(cameraAudioGain);
        cameraAudioGain.connect(compressor);
        compressor.connect(mixedAudio);
        
        // Create final stream
        const canvasStream = canvas.captureStream(fps);
        const audioTracks = mixedAudio.stream.getAudioTracks();
        
        const finalStream = new MediaStream([canvasStream.getVideoTracks()[0]]);
        if (audioTracks.length > 0) {
          finalStream.addTrack(audioTracks[0]);
        }

        // MediaRecorder setup with fallbacks
        let options;
        if (MediaRecorder.isTypeSupported('video/webm; codecs=vp9,opus')) {
          options = {
            mimeType: 'video/webm; codecs=vp9,opus',
            videoBitsPerSecond: 8000000,
            audioBitsPerSecond: 128000
          };
        } else if (MediaRecorder.isTypeSupported('video/webm; codecs=vp8,opus')) {
          options = {
            mimeType: 'video/webm; codecs=vp8,opus',
            videoBitsPerSecond: 5000000,
            audioBitsPerSecond: 128000
          };
        } else {
          options = {
            mimeType: 'video/webm',
            videoBitsPerSecond: 3000000,
            audioBitsPerSecond: 128000
          };
        }

        console.log("Using recording options:", options);
        
        mediaRecorder = new MediaRecorder(finalStream, options);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) {
            recordedChunks.push(event.data);
            console.log("Chunk recorded:", event.data.size, "bytes");
          }
        };

        mediaRecorder.onstop = () => {
          console.log("Recording stopped. Chunks:", recordedChunks.length);
          
          if (recordedChunks.length > 0) {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            console.log("Final recording size:", blob.size, "bytes");
            
            const url = URL.createObjectURL(blob);
            previewVideo.src = url;
            previewContainer.classList.remove("hidden");
            updateStatus("Recording completed! Preview and download below.", "ready");
          } else {
            updateStatus("Recording failed - no data captured", "recording");
            alert("Recording failed. Please try again.");
          }
          
          resetRecordingUI();
          if (audioContext) audioContext.close();
        };

        mediaRecorder.onerror = (event) => {
          console.error("Recording error:", event.error);
          updateStatus("Recording error occurred", "recording");
          alert("Recording error: " + event.error.message);
          resetRecordingUI();
          if (audioContext) audioContext.close();
        };

        // Start recording
        isRecording = true;
        if (selectedVideoSource === 'file') {
          videoPlayer.play().catch(e => console.log("Video play failed:", e));
        }
        mediaRecorder.start(100);
        drawFrame();
        
        console.log("Recording started successfully");

      } catch (error) {
        console.error("Recording setup failed:", error);
        updateStatus("Recording setup failed", "recording");
        alert("Failed to start recording: " + error.message);
        resetRecordingUI();
        if (audioContext) audioContext.close();
      }
    }

    function stopRecording() {
      console.log("Stopping recording...");
      
      if (mediaRecorder && isRecording) {
        isRecording = false;
        updateStatus("Finalizing recording...", "recording");
        
        try {
          mediaRecorder.stop();
        } catch (error) {
          console.error("Error stopping recording:", error);
          resetRecordingUI();
        }
      } else {
        console.log("No active recording to stop");
      }
    }

    // Event listeners
    startRecordingBtn.addEventListener("click", startRecording);
    stopRecordingBtn.addEventListener("click", stopRecording);

    // Download recording
    downloadRecordingBtn.addEventListener("click", () => {
      const url = previewVideo.src;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `reaction-video-${timestamp}.webm`;
      
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      updateStatus("Recording downloaded successfully!", "ready");
    });

    // Discard recording
    discardRecordingBtn.addEventListener("click", () => {
      previewContainer.classList.add("hidden");
      previewVideo.src = "";
      recordedChunks = [];
      updateStatus("Recording discarded. Ready for new recording.", "ready");
    });

    // Handle orientation change on mobile
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        videoPosition = { x: 0, y: 0 };
        updateVideoPosition();
      }, 500);
    });

    // Initialize
    updateStatus("Select a video source to begin", "ready");

    console.log("Professional Video Recorder with adjustable camera bar initialized successfully!");
  </script>
</body>
</html>
